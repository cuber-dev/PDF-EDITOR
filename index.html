<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>Invoice Fixer — Overlay Corrected Values</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <!-- PDF.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js"></script>
  <script>
    pdfjsLib.GlobalWorkerOptions.workerSrc =
      "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js";
  </script>
  <!-- pdf-lib -->
  <script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>
  <style>
    :root {
      --bg: #0f1724;
      --card: #0b1220;
      --accent: #8b5cf6;
      --muted: #94a3b8;
      --white: #e6eef8;
    }
    
    body {
      font-family: Inter, system-ui, Segoe UI, Roboto, Arial;
      background: linear-gradient(180deg, #071029 0%, #071a2b 100%);
      color: var(--white);
      margin: 0;
      padding: 24px;
    }
    
    .container {
      max-width: 1000px;
      margin: 0 auto;
    }
    
    h1 {
      margin: 0 0 12px;
      font-size: 20px
    }
    
    .card {
      background: var(--card);
      padding: 16px;
      border-radius: 10px;
      box-shadow: 0 6px 30px rgba(2, 6, 23, 0.6);
      margin-bottom: 12px
    }
    
    input[type=file] {
      color: var(--muted)
    }
    
    button {
      background: var(--accent);
      border: none;
      padding: 8px 12px;
      border-radius: 8px;
      color: white;
      cursor: pointer
    }
    
    button.secondary {
      background: transparent;
      border: 1px solid rgba(255, 255, 255, 0.06)
    }
    
    .row {
      display: flex;
      gap: 12px;
      align-items: center;
      flex-wrap: wrap
    }
    
    #preview {
      width: 100%;
      max-height: 560px;
      border-radius: 8px;
      overflow: auto;
      background: #071126;
      padding: 12px
    }
    
    canvas.pageCanvas {
      display: block;
      margin: 8px auto;
      border: 1px solid rgba(255, 255, 255, 0.03);
      box-shadow: 0 6px 18px rgba(2, 6, 23, 0.5)
    }
    
    .controls {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-top: 10px
    }
    
    label.small {
      font-size: 12px;
      color: var(--muted)
    }
    
    .info {
      font-size: 13px;
      color: var(--muted);
      margin-top: 8px
    }
    
    .footer {
      margin-top: 12px;
      font-size: 13px;
      color: var(--muted)
    }
    
    .page-block {
      margin-bottom: 18px
    }
    
    .field-list {
      font-size: 13px;
      color: var(--muted);
      margin-top: 6px
    }
    
    .small-input {
      width: 72px;
      padding: 6px;
      border-radius: 6px;
      border: 1px solid rgba(255, 255, 255, 0.03);
      background: transparent;
      color: var(--white)
    }
  </style>
</head>

<body>
  <div class="container">
    <h1>Invoice Fixer — Overlay corrected invoice numbers (client-side)</h1>
    
    <div class="card">
      <div class="row">
        <input id="fileInput" type="file" accept="application/pdf" />
        <button id="processBtn">Process & Preview</button>
        <button id="downloadBtn" disabled>Download Corrected PDF</button>
        <button id="resetBtn" class="secondary">Reset</button>
      </div>
      <div class="controls">
        <div>
          <label class="small">Global X offset (px)</label><br />
          <input id="xOffset" class="small-input" type="number" value="0" />
        </div>
        <div>
          <label class="small">Global Y offset (px)</label><br />
          <input id="yOffset" class="small-input" type="number" value="0" />
        </div>
        <div>
          <label class="small">Font size</label><br />
          <input id="fontSize" class="small-input" type="number" value="10" />
        </div>
        <div>
          <label class="small">White box padding</label><br />
          <input id="boxPadding" class="small-input" type="number" value="2" />
        </div>
      </div>
      
      <div class="info">
        This runs entirely in your browser. It tries to find numbers (Rate, Discount, SGST%, CGST%, Sub Total) using PDF text extraction, recalculates values and overlays corrected numbers on the original PDF pages. Works best for consistent invoice templates.
      </div>
    </div>
    
    <div id="preview" class="card">
      <div id="pagesContainer"></div>
    </div>
    
    <div class="footer">
      Built by Nandhu — if automatic positions are wrong, tweak X/Y offset and font size then re-generate. This page doesn't upload your PDF anywhere.
    </div>
  </div>
  
  <!-- Libraries from CDN -->
  <script src="https://unpkg.com/pdfjs-dist@3.10.349/build/pdf.min.js"></script>
  <script src="https://unpkg.com/pdf-lib@1.28.0/dist/pdf-lib.min.js"></script>
  
  <script>
    // === config ===
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://unpkg.com/pdfjs-dist@3.10.349/build/pdf.worker.min.js';
    
    const fileInput = document.getElementById('fileInput');
    const processBtn = document.getElementById('processBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const preview = document.getElementById('pagesContainer');
    const resetBtn = document.getElementById('resetBtn');
    
    const xOffsetInput = document.getElementById('xOffset');
    const yOffsetInput = document.getElementById('yOffset');
    const fontSizeInput = document.getElementById('fontSize');
    const boxPaddingInput = document.getElementById('boxPadding');
    
    let loadedPdfBytes = null;
    let processedPdfBytes = null;
    let pageMeta = []; // store per-page detections for overlaying in pdf-lib
    
    function clearPreview() {
      preview.innerHTML = '';
      processedPdfBytes = null;
      downloadBtn.disabled = true;
      pageMeta = [];
    }
    
    resetBtn.addEventListener('click', () => {
      fileInput.value = '';
      clearPreview();
    });
    
    processBtn.addEventListener('click', async () => {
      clearPreview();
      if (!fileInput.files || fileInput.files.length === 0) { alert('Choose a PDF file first'); return; }
      const f = fileInput.files[0];
      loadedPdfBytes = await f.arrayBuffer();
      await processPdf(loadedPdfBytes);
    });
    
    downloadBtn.addEventListener('click', async () => {
      if (!processedPdfBytes) { alert('No corrected PDF ready'); return; }
      const blob = new Blob([processedPdfBytes], { type: 'application/pdf' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'Corrected_Invoices.pdf';
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    });
    
    // Utility: number extractor (accepts commas, decimals)
    function extractNumberTokens(text) {
      // find numbers like 61,144.06 or 47768.80 or 6,000.00
      const regex = /(?:\d{1,3}(?:,\d{3})*|\d+)(?:\.\d+)?/g;
      const arr = text.match(regex) || [];
      return arr.map(s => s.replace(/,/g, ''));
    }
    
    // Normalize to float
    function toFloat(s) { const n = parseFloat(String(s).replace(/,/g, '')); return isNaN(n) ? null : n; }
    
    // Basic heuristic: search page text for patterns and capture nearby numeric items & coords
    async function processPdf(pdfBytes) {
      const loadingTask = pdfjsLib.getDocument({ data: pdfBytes });
      const pdf = await loadingTask.promise;
      
      // For rendering previews
      preview.innerHTML = '';
      
      // Collect page detections
      pageMeta = [];
      
      for (let p = 1; p <= pdf.numPages; p++) {
        const page = await pdf.getPage(p);
        const viewport = page.getViewport({ scale: 1.5 }); // render scale for preview
        // Render to canvas
        const canvas = document.createElement('canvas');
        canvas.className = 'pageCanvas';
        canvas.width = Math.floor(viewport.width);
        canvas.height = Math.floor(viewport.height);
        const ctx = canvas.getContext('2d');
        await page.render({ canvasContext: ctx, viewport }).promise;
        // Extract text content
        const textContent = await page.getTextContent();
        // textContent.items -> each has str and transform [a,b,c,d,e,f]
        // We'll create candidate tokens with positions scaled to viewport
        const items = textContent.items.map(it => {
          const t = it.transform; // [a,b,c,d,e,f] where e,f are x,y in pdf units
          // pdf.js transform to px for our canvas: use viewport.transform
          const [a, b, c, d, e, f] = t;
          const tx = viewport.transform[0] * e + viewport.transform[2] * f + viewport.transform[4];
          const ty = viewport.transform[1] * e + viewport.transform[3] * f + viewport.transform[5];
          return { str: it.str, transform: t, x: tx, y: ty, width: (it.width || 0) * viewport.scale, height: (it.height || 0) * viewport.scale };
        });
        
        // Heuristics to find candidates for important fields.
        // We'll look for numeric tokens and keywords 'Discount' 'Disc' 'Taxable' 'Sub Total' 'SubTotal' 'Net Total' 'SGST' 'CGST'
        const numericTokens = items.filter(it => /\d/.test(it.str) && /[0-9]/.test(it.str));
        // find keywords
        const keywords = {};
        items.forEach(it => {
          const s = it.str.trim().toLowerCase();
          if (s.includes('discount') || s.includes('disc')) keywords.discount = it;
          if (s.includes('taxable')) keywords.taxable = it;
          if (s.includes('sub total') || s.includes('subtotal')) keywords.subtotal = it;
          if (s.includes('net total') || s.includes('nettotal')) keywords.nettotal = it;
          if (s.includes('sgst')) keywords.sgst = it;
          if (s.includes('cgst')) keywords.cgst = it;
          if (s.includes('rate') && !keywords.rate) keywords.rate = it;
        });
        
        // Another heuristic: numeric tokens near keyword positions (x distance)
        const findNearestNumberAfter = (keywordItem, maxDist = 250) => {
          if (!keywordItem) return null;
          // choose numeric token on same line (y close) and x larger than keyword x (to its right)
          const cand = numericTokens
            .filter(n => Math.abs(n.y - keywordItem.y) < 18) // same line (approx)
            .sort((a, b) => Math.abs((a.x - keywordItem.x)) - Math.abs((b.x - keywordItem.x)));
          return cand[0] || null;
        };
        
        const pageDetection = { pageNumber: p, viewport, found: {} };
        
        // Attempt to detect Discount, Rate, SGST%, CGST%, Subtotal, Net total
        try {
          const discItem = keywords.discount || keywords.disc || null;
          const rateItem = keywords.rate || null;
          const sgstItem = keywords.sgst || null;
          const cgstItem = keywords.cgst || null;
          const subtotalItem = keywords.subtotal || null;
          const nettotalItem = keywords.nettotal || null;
          const taxableItem = keywords.taxable || null;
          
          // Detection: numbers near these labels
          const discNum = findNearestNumberAfter(discItem) || numericTokens.find(n => n.x > 350 && n.y > 300 && toFloat(n.str) && toFloat(n.str) < 1000000 && Math.abs(n.y - (discItem?.y || n.y)) < 40) || null;
          const rateNum = findNearestNumberAfter(rateItem) || numericTokens.find(n => n.x < 200 && toFloat(n.str) && toFloat(n.str) > 1000);
          const sgstNum = findNearestNumberAfter(sgstItem) || numericTokens.find(n => /\b14(\.0+)?\b/.test(n.str) || /\b\d{1,2}(\.\d+)?\b/.test(n.str));
          const cgstNum = findNearestNumberAfter(cgstItem) || null;
          const subtotalNum = findNearestNumberAfter(subtotalItem) || null;
          const netNum = findNearestNumberAfter(nettotalItem) || null;
          
          // fallback: look for big numbers in bottom-right area (totals)
          const bottomRightNums = numericTokens.filter(n => n.x > viewport.width * 0.4 && n.y > viewport.height * 0.5).sort((a, b) => b.x - a.x);
          
          pageDetection.found.rawCandidates = numericTokens.slice(0, 30).map(n => ({ s: n.str, x: n.x, y: n.y }));
          
          // Heuristic mapping: use the most frequent patterns in the invoices you showed:
          // - There's Rate near item lines (left)
          // - Discount sometimes appears as a numeric block like 6000.00 near bottom (we can pick the last big numeric that matches exact 6000 or small thousand)
          // - SGST & CGST often both 14.00 appear close to each other
          // We'll attempt:
          let rateVal = rateNum ? toFloat(rateNum.str) : null;
          let discountVal = discNum ? toFloat(discNum.str) : null;
          
          // If discount not found, search for recurring small numbers like 6000 near bottom
          if (!discountVal) {
            const lastBottom = bottomRightNums.slice(0, 6).map(n => toFloat(n.str)).filter(v => v && v < 20000 && v > 1);
            if (lastBottom.length) discountVal = lastBottom[lastBottom.length - 1];
          }
          
          // Try SGST/CGST percents detection (common to be 14.00)
          let sgstPercent = null,
            cgstPercent = null;
          if (sgstNum && /%/.test(sgstNum.str) === false && sgstNum.str.indexOf('.') > -1 && toFloat(sgstNum.str) < 100) {
            sgstPercent = toFloat(sgstNum.str);
          } else {
            // search for a nearby small number that is < 30 (percentage)
            const nearbyPerc = numericTokens.find(n => toFloat(n.str) && toFloat(n.str) > 0 && toFloat(n.str) < 30 && Math.abs(n.y - (sgstItem?.y || netNum?.y || 0)) < 40);
            if (nearbyPerc) sgstPercent = toFloat(nearbyPerc.str);
          }
          // CGST likely same as SGST
          cgstPercent = sgstPercent;
          
          // Some invoices show rate as the big number near top; if rate missing, pick the largest numeric on page that looks like price
          if (!rateVal) {
            const candidates = numericTokens.map(n => toFloat(n.str)).filter(v => v && v > 100 && v < 1000000);
            if (candidates.length) rateVal = Math.max(...candidates);
          }
          
          // Subtotal & Net number detection
          let subtotalVal = subtotalNum ? toFloat(subtotalNum.str) : null;
          let netVal = netNum ? toFloat(netNum.str) : null;
          if (!netVal) {
            // pick the last numeric at bottom of page
            const lastNum = numericTokens.filter(n => n.y > viewport.height * 0.5).slice(-1)[0];
            if (lastNum) netVal = toFloat(lastNum.str);
          }
          
          // If we have rate & discount & percents, compute corrected numbers
          if (rateVal != null && discountVal != null && sgstPercent != null && cgstPercent != null) {
            const taxable = rateVal - discountVal;
            const sgst = taxable * (sgstPercent / 100);
            const cgst = taxable * (cgstPercent / 100);
            const correctedSubtotal = taxable + sgst + cgst;
            const correctedNet = Math.round(correctedSubtotal);
            
            // Now find where to overlay: prefer positions of found values (taxable, sgst, cgst, subtotal, net)
            // For each value we will try to choose a target item to replace. Simple logic:
            // - taxable position -> keywords.taxable near text or numeric near it
            // - sgst position -> item near keyword 'SGST'
            // - cgst position -> item near 'CGST'
            // - subtotal -> near 'Sub Total' keyword or bottom right numeric
            // - net -> bottom-right final numeric
            
            const findReplacementPos = (preferKeywordItem, fallbackNumeric) => {
              if (preferKeywordItem) {
                const num = findNearestNumberAfter(preferKeywordItem) || numericTokens.find(n => Math.abs(n.y - preferKeywordItem.y) < 24);
                if (num) return num;
              }
              if (fallbackNumeric) return fallbackNumeric;
              return null;
            };
            
            const taxablePos = findReplacementPos(taxableItem, numericTokens.find(n => n.y > viewport.height * 0.3 && n.x > viewport.width * 0.2));
            const sgstPos = findReplacementPos(sgstItem, numericTokens.find(n => n.str.includes(String(sgstPercent))));
            const cgstPos = findReplacementPos(cgstItem, numericTokens.find(n => n.str.includes(String(cgstPercent))));
            const subtotalPos = findReplacementPos(subtotalItem, bottomRightNums[1] || bottomRightNums[0]);
            const netPos = findReplacementPos(nettotalItem, bottomRightNums[0]);
            
            pageDetection.found.rate = { value: rateVal, pos: rateNum };
            pageDetection.found.discount = { value: discountVal, pos: discNum || bottomRightNums[bottomRightNums.length - 2] };
            pageDetection.found.taxable = { value: taxable, pos: taxablePos };
            pageDetection.found.sgstPercent = sgstPercent;
            pageDetection.found.cgstPercent = cgstPercent;
            pageDetection.found.sgst = { value: sgst, pos: sgstPos };
            pageDetection.found.cgst = { value: cgst, pos: cgstPos };
            pageDetection.found.subtotal = { value: correctedSubtotal, pos: subtotalPos };
            pageDetection.found.net = { value: correctedNet, pos: netPos };
            
            // For preview: draw overlays on canvas context
            const ctxOverlay = canvas.getContext('2d');
            ctxOverlay.save();
            ctxOverlay.font = (Number(fontSizeInput.value) || 10) + 'px monospace';
            ctxOverlay.fillStyle = 'rgba(255,255,255,0.95)';
            ctxOverlay.strokeStyle = 'rgba(0,0,0,0.0)';
            ctxOverlay.fillStyle = 'rgba(255,255,255,0.96)';
            
            function drawOverlayFor(target, displayText) {
              if (!target || !target.pos) return;
              const pos = target.pos;
              const padding = Number(boxPaddingInput.value) || 2;
              const text = (typeof displayText === 'number') ? displayText.toLocaleString('en-IN', { minimumFractionDigits: 2, maximumFractionDigits: 2 }) : displayText;
              // measure
              const measure = ctxOverlay.measureText(text);
              const w = measure.width + padding * 6;
              const h = Number(fontSizeInput.value || 10) + padding * 4;
              // Coordinates: pos.x,pos.y are text start. We'll draw white rect slightly above pos.y
              const rx = (pos.x) + (Number(xOffsetInput.value) || 0);
              const ry = (pos.y) - h / 1.5 + (Number(yOffsetInput.value) || 0);
              ctxOverlay.fillStyle = 'rgba(255,255,255,0.96)';
              ctxOverlay.fillRect(rx - padding, ry - padding, w, h + padding);
              ctxOverlay.fillStyle = '#000';
              ctxOverlay.fillText(text, rx + 2, ry + h - padding - 3);
            }
            
            drawOverlayFor(pageDetection.found.taxable, pageDetection.found.taxable.value);
            drawOverlayFor(pageDetection.found.sgst, pageDetection.found.sgst.value);
            drawOverlayFor(pageDetection.found.cgst, pageDetection.found.cgst.value);
            drawOverlayFor(pageDetection.found.subtotal, pageDetection.found.subtotal.value);
            drawOverlayFor(pageDetection.found.net, pageDetection.found.net.value);
            
            ctxOverlay.restore();
            
            pageDetection.calculated = true;
          } else {
            pageDetection.calculated = false;
          }
          
        } catch (err) {
          console.error('page parse error', err);
        }
        
        // Show page preview + small report
        const pageBlock = document.createElement('div');
        pageBlock.className = 'page-block';
        pageBlock.appendChild(canvas);
        const info = document.createElement('div');
        info.className = 'field-list';
        info.textContent = `Page ${p} — detection summary (see console for raw tokens).`;
        pageBlock.appendChild(info);
        preview.appendChild(pageBlock);
        
        // push meta for pdf-lib overlay later
        pageMeta.push({ pageNumber: p, viewport, detection: pageDetection });
      } // end pages loop
      
      // After previews, prepare final PDF with overlays using pdf-lib
      await createCorrectedPdf(loadedPdfBytes, pageMeta);
      downloadBtn.disabled = false;
      alert('Preview generated. If overlays look OK, click "Download Corrected PDF". Tweak offsets if numbers misaligned and re-process.');
    }
    
    // Create corrected PDF using pdf-lib
    async function createCorrectedPdf(origPdfBytes, meta) {
      const { PDFDocument, rgb, StandardFonts } = PDFLib;
      const pdfDoc = await PDFDocument.load(origPdfBytes);
      
      const pages = pdfDoc.getPages();
      
      // font
      const font = await pdfDoc.embedFont(StandardFonts.Helvetica);
      
      for (const m of meta) {
        const pIndex = m.pageNumber - 1;
        const page = pages[pIndex];
        const pWidth = page.getWidth();
        const pHeight = page.getHeight();
        
        const det = m.detection;
        if (!det.calculated) continue;
        
        const scale = det.viewport.scale || 1.5; // viewport.scale used when rendering preview; pdf units conversion needed
        // pdf.js gave positions in px based on preview viewport scale. We need to convert back to PDF points.
        // Approximate conversion: pdfPoint = canvasPx * (pdfWidth / canvasWidth)
        const canvasW = det.viewport.width;
        const canvasH = det.viewport.height;
        // actual pdf dimensions in points roughly equal to page.getWidth/Height
        const pdfW = pWidth;
        const pdfH = pHeight;
        
        const xScale = pdfW / canvasW;
        const yScale = pdfH / canvasH;
        
        const pad = Number(boxPaddingInput.value) || 2;
        const fSize = Number(fontSizeInput.value) || 10;
        
        // helper to compute pdf-lib rectangle & text
        function drawReplacement(target, value) {
          if (!target || !target.pos) return;
          const pos = target.pos;
          const text = (typeof value === 'number') ? value.toLocaleString('en-IN', { minimumFractionDigits: 2, maximumFractionDigits: 2 }) : value;
          
          const rx = (pos.x + (Number(xOffsetInput.value) || 0)) * xScale;
          // Convert canvas y to PDF y: pdf y origin is bottom-left while canvas y origin is top-left.
          const ry_canvas = pos.y + (Number(yOffsetInput.value) || 0);
          const ry = pdfH - (ry_canvas * yScale);
          
          const measureWidth = font.widthOfTextAtSize(text, fSize);
          const measureHeight = fSize + 2;
          
          const rectX = rx - pad * xScale;
          const rectY = ry - measureHeight - pad * yScale;
          const rectW = measureWidth + pad * 8;
          const rectH = measureHeight + pad * 4;
          
          // Draw white rectangle (to cover old)
          page.drawRectangle({
            x: rectX,
            y: rectY,
            width: rectW,
            height: rectH,
            color: PDFLib.rgb(1, 1, 1),
          });
          
          // Draw text (black)
          page.drawText(text, {
            x: rectX + 3,
            y: rectY + (rectH - measureHeight) / 2,
            size: fSize,
            font,
            color: PDFLib.rgb(0, 0, 0),
          });
        }
        
        drawReplacement(det.found.taxable, det.found.taxable.value);
        drawReplacement(det.found.sgst, det.found.sgst.value);
        drawReplacement(det.found.cgst, det.found.cgst.value);
        drawReplacement(det.found.subtotal, det.found.subtotal.value);
        drawReplacement(det.found.net, det.found.net.value);
      }
      
      const out = await pdfDoc.save();
      processedPdfBytes = out;
    }
  </script>
</body>

</html>